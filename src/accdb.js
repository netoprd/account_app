var db = openDatabase('Accountdb', '1.0', 'db for p2p accounting app', 2 * 1024 * 1024);

function initTables() {
   db.transaction(function (tx) {
      tx.executeSql('CREATE TABLE IF NOT EXISTS chartOfAccount (id INTEGER PRIMARY KEY, accountCode UNIQE VARCHAR, accountName VARCHAR, accountType VARCHAR, isHeader BOOLEAN DEFAULT FALSE, headerAccountCode VARCHAR,  headerAccountName VARCHAR, balance NUMBER, createdBy VARCHAR, createdOn DATE)');

    tx.executeSql('CREATE TABLE IF NOT EXISTS journalDefinitionDetails (id INTEGER PRIMARY KEY, journalDefinationId NUMBER, accountCode VARCHAR, amount NUMBER, canChangeAccountCode BOOLEAN DEFAULT FALSE, canChangeAmount BOOLEAN DEFAULT FALSE, canChangeIsCredited BOOLEAN DEFAULT FALSE, compulsory BOOLEAN DEFAULT FALSE, isCredited BOOLEAN DEFAULT FALSE)'); 

      tx.executeSql('CREATE TABLE IF NOT EXISTS journalDefinationDeitail (id INTEGER PRIMARY KEY, journalDefination NUMBER, accountCode VARCHAR, amount NUMBER, canChangeAccountCode BOOLEAN DEFAULT FALSE, canChangeAmount BOOLEAN DEFAULT FALSE, canChangeIsCredited BOOLEAN DEFAULT FALSE, createdBy VARCHAR, createdOn DATE, compulsory BOOLEAN DEFAULT FALSE, isCredited BOOLEAN DEFAULT FALSE)');

   })
}

//  export function savechartofaccount(datatosave) {
var savechartofaccount = function (datatosave) {
   initTables()
   db.transaction(function (tx) {
      tx.executeSql('INSERT INTO chartOfAccount(accountCode, accountName, accountType, isHeader, headerAccountCode, headerAccountName, balance, createdBy, createdOn) VALUES (?,?,?,?,?,?,?,?,?)', [datatosave.accountCode, datatosave.accountName, datatosave.accountType, datatosave.isHeader, datatosave.headerAccountCode, datatosave.headerAccountName, datatosave.balance, datatosave.createdBy, datatosave.createdOn], function (tx, results) {
         console.log(results);
         return results
      });
   });
}

const editChartOfAccount = function (id, datatoedit) {
   db.transaction(function (tx) {
      tx.executeSql('update chartOfAccount set accountCode =?, accountName =?, accountType =?, isHeader =?, headerAccountCode =?,  headerAccountName =?, balance =? where id=?', [datatoedit.accountCode, datatoedit.accountName, datatoedit.accountType, datatoedit.isHeader, datatoedit.headerAccountCode, datatoedit.headerAccountName, datatoedit.balance, id]);
   });

   var result = [];
   db.transaction(function (tx) {
      tx.executeSql(`Select * from chartOfAccount where id = ${id}`, [], function (tx, rs) {
         for (var i = 0; i < rs.rows.length; i++) {
            var row = rs.rows.item(i)
            result[i] = {
               id: row['id'],
               name: row['name']
            }
         }
         console.log(result);
         return (result); // <-- new bit here
      }, errorHandler);
   });
}

function errorHandler(tx, e) {
   return (`Somthing went wrong, ${e.message}`)
}


const getallchartofaccount = function () {
   var result = [];
   db.transaction(function (tx) {
      tx.executeSql(`Select * from chartOfAccount`, [], function (tx, rs) {
         for (var i = 0; i < rs.rows.length; i++) {
            var row = rs.rows.item(i)
            result[i] = {
               id: row['id'],
               name: row['accountCode']
            }
         }
         console.log(result);
         return (result); // <-- new bit here
      }, errorHandler);
   });
}

const getchartofaccountbyId = function (id) {
   var result = [];
   db.transaction(function (tx) {
      tx.executeSql(`Select * from chartOfAccount where id = ${id}`, [], function (tx, rs) {
         // for (var i = 0; i < rs.rows.length; i++) {
         //    var row = rs.rows.item(i)
         //    result[i] = {
         //       id: row['id'],
         //       name: row['accountCode']
         //    }
         // }
         result = rs.rows
         // alert(result); // <-- new bit here
         console.log(result);
         callback(result); // <-- new bit here
      }, errorHandler);
   });
}



  const savejournalDefinition = (datatosave) =>{
        initTables()
        let pid = ""
        db.transaction(function(tx) {
            tx.executeSql('INSERT INTO journalDefination(approvedBy, approvedOn, autoGenerated, canAddMoreItems, canRemoveMoreItems, createdBy, createdOn, dateOfMonth, journalDescription, remark, transactionDate, transactionRef) VALUES (?,?,?,?,?,?,?,?,?,?,?,?)',[datatosave.approvedBy, datatosave.approvedOn, datatosave.autoGenerated, datatosave.canAddMoreItems, datatosave.canRemoveMoreItems, datatosave.createdBy, datatosave.createdOn, datatosave.dateOfMonth, datatosave.journalDescription, datatosave.remark, datatosave.transactionDate, datatosave.transactionRef], function(tx, results) {
                pid = results.insertId
            });

            let allchild = [];

            for (const item of datatosave.journalDefinitionDetails){
            let re = '['+5 +',' +''+ item.accountCode+',' +''+  item.amount+',' +''+ item.canChangeAccountCode+',' +''+   item.canChangeAmount +',' +''+  item.canChangeIsCredited +',' +''+ item.compulsory +',' +''+  item.isCredited +'];'
            allchild.push(re)
           }

           
           tx.executeSql('INSERT INTO journalDefinitionDetails(journalDefinationId, accountCode, amount, canChangeAccountCode, canChangeAmount, canChangeIsCredited, compulsory, isCredited) VALUES (?,?,?,?,?,?,?,?)', allchild, [], function(tx, results){

            });
          

        });

       }

    //    function loopt (data, pid){
    //     const re = 'INSERT INTO journalDefinitionDetails(journalDefination, accountCode, amount, canChangeAccountCode, canChangeAmount, canChangeIsCredited, compulsory, isCredited) VALUES'+ ''
    //          for (const item of data){
    //            let par = (pid, item.accountCode, item.amount, item.canChangeAccountCode, item.canChangeAmount, item.canChangeIsCredited, item.compulsory, item.isCredited) 

    //            re = + par

    //         }

    //         return re
    //     }

  const dbData = {
    savechartofaccount, 
    editChartOfAccount,
    getallchartofaccount,
    getchatofaccountbyId,
    savejournalDefinition
  }
  export default dbData;